/*****************************************************************************
 * Project: RooFit                                                           *
 *                                                                           *
 * This code was autogenerated by RooClassFactory                            *
 *****************************************************************************/

// Your description goes here...

#include "Riostream.h"

#include "NASixty.h"
#include "RooAbsReal.h"
#include "RooAbsCategory.h"
#include <math.h>
#include "TMath.h"

 NASixty::NASixty(const char *name, const char *title,
                        RooAbsReal& _x,
                        Double_t _alphal,
                        Double_t _pl1,
                        Double_t _pl2,
                        Double_t _pl3,
                        Double_t _alphar,
                        Double_t _pr1,
                        Double_t _pr2,
                        Double_t _pr3,
                        RooAbsReal& _x0,
                        Double_t    _x0Shift,
                        RooAbsReal& _sigma,
                        Double_t    _sigmaShift) :
   RooAbsPdf(name,title),
   x("x","x",this,_x),
   alphal(_alphal),
   pl1(_pl1),
   pl2(_pl2),
   pl3(_pl3),
   alphar(_alphar),
   pr1(_pr1),
   pr2(_pr2),
   pr3(_pr3),
   x0("x0","x0",this,_x0),
   x0Shift(_x0Shift),
   sigma("sigma","sigma",this,_sigma),
   sigmaShift(_sigmaShift)
 {
 }


 NASixty::NASixty(const NASixty& other, const char* name) :
   RooAbsPdf(other,name),
   x("x",this,other.x),
   alphal(other.alphal),
   pl1(other.pl1),
   pl2(other.pl2),
   pl3(other.pl3),
   alphar(other.alphar),
   pr1(other.pr1),
   pr2(other.pr2),
   pr3(other.pr3),
   x0("x0",this,other.x0),
   x0Shift(other.x0Shift),
   sigma("sigma",this,other.sigma),
   sigmaShift(other.sigmaShift)
 {
 }


 Double_t NASixty::evaluate() const
 {
   Double_t x0Shifted = x0+x0Shift;
   Double_t sigmaShifted = sigma*sigmaShift;
   Double_t t = (x-x0Shifted)/sigmaShift;
   Double_t t0;

   if(t<alphal){
     t0 = 1+TMath::Power(pl1*(alphal-t),(pl2-pl3*TMath::Sqrt(alphal-t)));
   }
   if( (t>=alphal) && (t<alphar)){
     t0 = 1;
   }
   if(t>=alphar){
     t0 = 1+TMath::Power(pr1*(t-alphar),(pr2-pr3*TMath::Sqrt(t-alphar)));
   }

   return exp(-0.5*TMath::Power(t/t0,2));
 }
